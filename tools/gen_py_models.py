from pathlib import Path
import re

path = Path(__file__).parent / "../src/core/qtypes.h"
out_path = Path(__file__).parent / "../src/python/files/events.py"

# extended Qt -> Python base types
BASE_TYPE_MAP = {
    "QByteArray": "bytes",
    "QString": "str",
    "QStringList": "List[str]",
    "bool": "bool",
    "qint64": "int",
    "qint32": "int",
    "quint64": "int",
    "quint32": "int",
    "double": "float",
    "float": "float",
    "int": "int",
}

def qt_to_py_type(qt_type: str) -> str:
    qt_type = qt_type.strip()
    # handle QMap<K,V> -> dict[K,V]
    map_match = re.match(r"QMap<(.+?),\s*(.+)>", qt_type)
    if map_match:
        k, v = map_match.groups()
        return f"dict[{qt_to_py_type(k)}, {qt_to_py_type(v)}]"
    # handle QSharedPointer<T> -> T
    sp_match = re.match(r"QSharedPointer<(.+)>", qt_type)
    if sp_match:
        inner = sp_match.group(1)
        return qt_to_py_type(inner)
    # fallback to base types
    return BASE_TYPE_MAP.get(qt_type, qt_type)

def find_qevent_classes(header: str):
    pattern = re.compile(r'class\s+(\w+)\s+(?:final\s+)?\s*:\s*public\s+QEventBase\s*{')
    return pattern.findall(header)

def parse_class_body(class_name: str, body: str):
    py_class_name = class_name
    if py_class_name.startswith("QEvent"):
        py_class_name = py_class_name[len("QEvent"):]

    members = []
    comment_type = None
    comment_default = None

    for line in body.splitlines():
        line = line.strip()
        if line.startswith("//"):
            t_match = re.search(r't:(.+?)(\s|$)', line)
            d_match = re.search(r'd:(.+?)(\s|$)', line)
            comment_type = t_match.group(1).strip() if t_match else None
            comment_default = d_match.group(1).strip() if d_match else None
            continue

        if line.startswith("Q_PROPERTY") or line.startswith("Q_GADGET"):
            continue

        member_match = re.match(r'(\w+(<.*?>)?)\s+(\w+)(\s*=\s*(.+))?;', line)
        if member_match:
            qt_type, _, name, _, default_value = member_match.groups()
            py_type = comment_type or qt_to_py_type(qt_type)
            if comment_default:
                default = comment_default
            elif default_value:
                default = default_value.strip()
            else:
                default = None
            members.append((name, py_type, default))
            comment_type = None
            comment_default = None

    if not members:
        return None

    # sort members: no-default first, default last
    members.sort(key=lambda x: x[2] is not None)

    output = [f"@dataclass", f"class {py_class_name}(QEventBase, QClass):"]
    for name, py_type, default in members:
        if default is not None:
            output.append(f"    {name}: {py_type} = {default}")
        else:
            output.append(f"    {name}: {py_type}")
    return "\n".join(output) + "\n"

# ===
lines = [
    "# note: this file is automatically generated (tools/gen_py_models.py)",
    "# which parses `src/core/qtypes.h`",
    "",
    "from dataclasses import dataclass, field",
    "from typing import List, Any",
    "from .models import *",
    "",
]

header_content = path.read_text()

# scan the file for classes inheriting from QEventBase
qevent_classes = find_qevent_classes(header_content)

# extract the body of each class and parse it
for class_name in qevent_classes:
    # match the entire class body
    pattern = re.compile(r'class\s+' + re.escape(class_name) + r'.*?{(.*?)};', re.S)
    match = pattern.search(header_content)
    if match:
        body = match.group(1)
        dataclass_code = parse_class_body(class_name, body)
        if dataclass_code:
            lines.append(dataclass_code)

out_path.write_text("\n".join(lines))
print(f"{len(qevent_classes)} dataclasses written to {out_path}")
